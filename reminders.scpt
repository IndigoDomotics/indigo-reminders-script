property defaultAccountName : ""on makeNewReminder(reminder_record)	# reminder_record should be a record (or Python dictionary that's passed in	# using the py-applescript library) that contains the following elements:	#	title [str, required] - the name of the reminder	#	destination_list [str, required] - the name of the list into which to create the new reminder	#	destination_account [str, optional] - name of the account (defaults to the first one or the default setting)	#	due_date [date, optional] - the due date for the reminder (defaults to no date), which will also be the reminder date	# 	notes [str, optional] - the text to put into the Notes field of the reminder (defaults to "")	#	priority_string [str, optional] - the priority (defaults to none) none, high, medium, low	tell application "Reminders"		# First, we see if the default account used by any iterations of the script 		# has been set - if so we use that account, otherwise we find the first account		# that's not the "Smart Lists" account.		try			set theAccount to account (destination_account of reminder_record)		on error errorMessage number errorNumber			if (exists account (my defaultAccountName)) then				set theAccount to account (my defaultAccountName)			else				if name of first account is "Smart Lists" then					set theAccount to second account				else					set theAccount to first account				end if				set my defaultAccountName to name of theAccount			end if		end try		set reminderProperties to {}		# Next, extract the required elements (name, list name) and return an error if one is missing.		# You could also do validation here as well.		try			set reminderProperties to reminderProperties & {name:title of reminder_record}			set reminderList to list (destination_list of reminder_record) of theAccount		on error errorMessage number errorNumber			return {success:false, reason:{error_number:errorNumber, error_message:errorMessage}}		end try		# Next, we'll deal with optional params		try			set reminderProperties to reminderProperties & {due date:due_date of reminder_record}		end try		try			set reminderProperties to reminderProperties & {body:(notes of reminder_record)}		end try		set priority_num to 0		try			set priority_string to priority_string of reminder_record			if priority_string is "high" then set priority_num to 1			if priority_string is "medium" then set priority_num to 5			if priority_string is "low" then set priority_num to 9		end try		set reminderProperties to reminderProperties & {priority:priority_num}		# Finally, create the reminder		set newReminder to make new reminder ¬			with properties reminderProperties ¬			at reminderList				return {success:true, reminder_id:(id of newReminder as string)}			end tellend makeNewReminderon completeReminder(completion_record)	set deleteReminder to false	try		set deleteReminder to delete_reminder of completion_record	end try	tell application "Reminders"		try			set rem to reminder id (reminder_id of completion_record)			set completed of rem to true			set completion date of rem to current date		on error errorMessage number errorNumber			return {success:false, reason:{error_number:errorNumber, error_message:errorMessage}}		end try		if deleteReminder then			set reply to my deleteReminder(reminder_id of completion_record)			if not (success of reply) then				return reply			end if		end if		return {success:true, reminder_id:(reminder_id of completion_record)}	end tellend completeReminderon deleteReminder(identifier)	tell application "Reminders"		try			delete reminder id identifier			return {success:true, reminder_id:(identifier as string)}		on error errorMessage number errorNumber			return {success:false, reason:{error_number:errorNumber, error_message:errorMessage}}		end try	end tellend deleteReminderon setDefaultAccountName(account_name)	# You can set the default account to use for all subsequent API calls using	# this handler, then you don't need to include account in the various records.	tell application "Reminders"		# Check to see if there is an account with that name, and if so then use that		# one as the default. Otherwise just return a failure and reason.		try			set theAccount to account account_name			set my defaultAccountName to account_name			return {success:true, account_name:my defaultAccountName}		on error errorMessage number errorNumber			return {success:false, reason:{error_number:errorNumber, error_message:errorMessage}}		end try	end tellend setDefaultAccountNameon getDefaultAccountName()	if defaultAccountName is "" then		tell application "Reminders"			if name of first account is "Smart Lists" then				set my defaultAccountName to name of second account			else				set my defaultAccountName to name of first account			end if		end tell	end if	return defaultAccountNameend getDefaultAccountName